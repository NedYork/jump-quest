{"version":3,"sources":["webpack:///webpack/bootstrap 88a97a98bc1273ccc712","webpack:///./js/game.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAuB;AACvB,wBAAuB;;AAEvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2BAA0B,UAAU;AACpC;AACA,2BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B;AAC1B,4BAA2B;;AAE3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,EAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 88a97a98bc1273ccc712\n **/","// wrapper for our game \"classes\", \"methods\" and \"objects\"\nwindow.Game = {};\n\n// wrapper for \"class\" Rectangle\n(function(){\n  function Rectangle(left, top, width, height){\n    this.left = left || 0;\n    this.top = top || 0;\n    this.width = width || 0;\n    this.height = height || 0;\n    this.right = this.left + this.width;\n    this.bottom = this.top + this.height;\n  }\n\n  Rectangle.prototype.set = function(left, top, /*optional*/width, /*optional*/height){\n    this.left = left;\n    this.top = top;\n    this.width = width || this.width;\n    this.height = height || this.height;\n    this.right = (this.left + this.width);\n    this.bottom = (this.top + this.height);\n  };\n\n  Rectangle.prototype.within = function(r) {\n    return (r.left <= this.left &&\n        r.right >= this.right &&\n        r.top <= this.top &&\n        r.bottom >= this.bottom);\n  };\n\n  Rectangle.prototype.overlaps = function(r) {\n    return (this.left < r.right &&\n        r.left < this.right &&\n        this.top < r.bottom &&\n        r.top < this.bottom);\n  }\n\n  // add \"class\" Rectangle to our Game object\n  Game.Rectangle = Rectangle;\n})();\n\n// wrapper for \"class\" Camera (avoid global objects)\n(function(){\n\n  // possibles axis to move the camera\n  var AXIS = {\n    NONE: \"none\",\n    HORIZONTAL: \"horizontal\",\n    VERTICAL: \"vertical\",\n    BOTH: \"both\"\n  };\n\n  // Camera constructor\n  function Camera(xView, yView, canvasWidth, canvasHeight, worldWidth, worldHeight)\n  {\n    // position of camera (left-top coordinate)\n    this.xView = xView || 0;\n    this.yView = yView || 0;\n\n    // distance from followed object to border before camera starts move\n    this.xDeadZone = 0; // min distance to horizontal borders\n    this.yDeadZone = 0; // min distance to vertical borders\n\n    // viewport dimensions\n    this.wView = canvasWidth;\n    this.hView = canvasHeight;\n\n    // allow camera to move in vertical and horizontal axis\n    this.axis = AXIS.BOTH;\n\n    // object that should be followed\n    this.followed = null;\n\n    // rectangle that represents the viewport\n    this.viewportRect = new Game.Rectangle(this.xView, this.yView, this.wView, this.hView);\n\n    // rectangle that represents the world's boundary (room's boundary)\n    this.worldRect = new Game.Rectangle(0, 0, worldWidth, worldHeight);\n\n  }\n\n  // gameObject needs to have \"x\" and \"y\" properties (as world(or room) position)\n  Camera.prototype.follow = function(gameObject, xDeadZone, yDeadZone)\n  {\n    this.followed = gameObject;\n    this.xDeadZone = xDeadZone;\n    this.yDeadZone = yDeadZone;\n  }\n\n  Camera.prototype.update = function()\n  {\n    // keep following the player (or other desired object)\n    if(this.followed != null)\n    {\n      if(this.axis == AXIS.HORIZONTAL || this.axis == AXIS.BOTH)\n      {\n        // moves camera on horizontal axis based on followed object position\n        if(this.followed.x - this.xView  + this.xDeadZone > this.wView)\n          this.xView = this.followed.x - (this.wView - this.xDeadZone);\n        else if(this.followed.x  - this.xDeadZone < this.xView)\n          this.xView = this.followed.x  - this.xDeadZone;\n\n      }\n      if(this.axis == AXIS.VERTICAL || this.axis == AXIS.BOTH)\n      {\n        // moves camera on vertical axis based on followed object position\n        if(this.followed.y - this.yView + this.yDeadZone > this.hView)\n          this.yView = this.followed.y - (this.hView - this.yDeadZone);\n        else if(this.followed.y - this.yDeadZone < this.yView)\n          this.yView = this.followed.y - this.yDeadZone;\n      }\n\n    }\n\n    // update viewportRect\n    this.viewportRect.set(this.xView, this.yView);\n\n    // don't let camera leaves the world's boundary\n    if(!this.viewportRect.within(this.worldRect))\n    {\n      if(this.viewportRect.left < this.worldRect.left)\n        this.xView = this.worldRect.left;\n      if(this.viewportRect.top < this.worldRect.top)\n        this.yView = this.worldRect.top;\n      if(this.viewportRect.right > this.worldRect.right)\n        this.xView = this.worldRect.right - this.wView;\n      if(this.viewportRect.bottom > this.worldRect.bottom)\n        this.yView = this.worldRect.bottom - this.hView;\n    }\n\n  }\n\n  // add \"class\" Camera to our Game object\n  Game.Camera = Camera;\n\n})();\n\n// wrapper for \"class\" Player\n(function(){\n  function Player(x, y){\n    // (x, y) = center of object\n    // ATTENTION:\n    // it represents the player position on the world(room), not the canvas position\n    this.x = x;\n    this.y = y;\n\n    // move speed in pixels per second\n    this.velX = 0;\n    this.velY = 0;\n\n    // render properties\n    this.width = 50;\n    this.height = 50;\n    this.jumping = false;\n    this.grounded = false;\n  }\n\n  // Collision colCheck\n  function colCheck(shapeA, shapeB) {\n    var vX = (shapeA.x + (shapeA.width / 2)) - (shapeB.x + (shapeB.width / 2)),\n        vY = (shapeA.y + (shapeA.height / 2)) - (shapeB.y + (shapeB.height / 2)),\n        hWidths = (shapeA.width / 2) + (shapeB.width / 2),\n        hHeights = (shapeA.height / 2) + (shapeB.height / 2),\n        colDir = null;\n\n      if (Math.abs(vX) < hWidths && Math.abs(vY) < hHeights) {         // figures out on which side we are colliding (top, bottom, left, or right)\n        var oX = hWidths - Math.abs(vX),\n            oY = hHeights - Math.abs(vY);\n        if (oX >= oY) {\n              if (vY > 0) {\n                  colDir = \"t\";\n                  shapeA.y += oY;\n              } else {\n                  colDir = \"b\";\n                  shapeA.y -= oY;\n              }\n          } else {\n              if (vX > 0) {\n                  colDir = \"l\";\n                  shapeA.x += oX;\n              } else {\n                  colDir = \"r\";\n                  shapeA.x -= oX;\n              }\n          }\n      }\n      return colDir;\n  }\n\n  Player.prototype.update = function(step, worldWidth, worldHeight){\n    // parameter step is the time between frames ( in seconds )\n\n    // check controls and move the player accordingly\n    if(Game.controls.left)\n      this.velX = -200 * step;\n      // this.x -= this.velX * step;\n    if(Game.controls.up)\n      this.velY = 200 * step;\n      // added grounding and jumping\n      this.jumping = true;\n      this.grounded = false;\n    if(Game.controls.right)\n      this.velX = 200 * step;\n      // this.x += this.velX * step;\n    if(Game.controls.down)\n      this.y += this.velY * step;\n\n    this.velX *= Game.FRICTION;\n    this.velY += Game.GRAVITY;\n\n    // collision check on player\n    var dir = colCheck(this, Game.Rectangle);\n    if (dir === \"l\" || dir === \"r\") {\n      this.velX = 0;\n      this.jumping = false;\n    } else if (dir === \"b\") {\n      this.grounded = true;\n      this.jumping = false;\n    } else if (dir === \"t\") {\n      this.velY *= -1;\n      console.log('hit top');\n    }\n\n    if (this.grounded) {\n      this.velY = 0;\n    }\n\n    this.x += this.velX;\n    this.y += this.velY;\n\n    // don't let player leaves the world's boundary\n    if(this.x - this.width/2 < 0){\n      this.x = this.width/2;\n    }\n    if(this.y - this.height/2 < 0){\n      this.y = this.height/2;\n    }\n    if(this.x + this.width/2 > worldWidth){\n      this.x = worldWidth - this.width/2;\n    }\n    if(this.y + this.height/2 > worldHeight){\n      this.y = worldHeight - this.height/2;\n    }\n  }\n\n  Player.prototype.draw = function(context, xView, yView){\n    // draw a simple rectangle shape as our player model\n    context.save();\n    context.fillStyle = \"black\";\n    // before draw we need to convert player world's position to canvas position\n    context.fillRect((this.x-this.width/2) - xView, (this.y-this.height/2) - yView, this.width, this.height);\n    context.restore();\n  }\n\n  // add \"class\" Player to our Game object\n  Game.Player = Player;\n\n})();\n\n// wrapper for \"class\" Map\n(function(){\n  function Map(width, height){\n    // map dimensions\n    this.width = width;\n    this.height = height;\n\n    // map texture\n    this.image = null;\n  }\n\n  // generate an example of a large map\n  Map.prototype.generate = function(){\n    var ctx = document.createElement(\"canvas\").getContext(\"2d\");\n    ctx.canvas.width = this.width;\n    ctx.canvas.height = this.height;\n\n    var rows = ~~(this.width/44) + 1;\n    var columns = ~~(this.height/44) + 1;\n\n    var color = \"red\";\n    ctx.save();\n    ctx.fillStyle = \"red\";\n    for (var x = 0, i = 0; i < rows; x+=44, i++) {\n      ctx.beginPath();\n      for (var y = 0, j=0; j < columns; y+=44, j++) {\n        ctx.rect (x, y, 40, 40);\n      }\n      color = (color == \"red\" ? \"blue\" : \"red\");\n      ctx.fillStyle = color;\n      ctx.fill();\n      ctx.closePath();\n    }\n    ctx.restore();\n\n    // store the generate map as this image texture\n    this.image = new Image();\n    this.image.src = ctx.canvas.toDataURL(\"image/png\");\n\n    // clear context\n    ctx = null;\n  }\n\n  // draw the map adjusted to camera\n  Map.prototype.draw = function(context, xView, yView){\n    // easiest way: draw the entire map changing only the destination coordinate in canvas\n    // canvas will cull the image by itself (no performance gaps -> in hardware accelerated environments, at least)\n    //context.drawImage(this.image, 0, 0, this.image.width, this.image.height, -xView, -yView, this.image.width, this.image.height);\n\n    // didactic way:\n\n    var sx, sy, dx, dy;\n          var sWidth, sHeight, dWidth, dHeight;\n\n    // offset point to crop the image\n    sx = xView;\n    sy = yView;\n\n    // dimensions of cropped image\n    sWidth =  context.canvas.width;\n    sHeight = context.canvas.height;\n\n    // if cropped image is smaller than canvas we need to change the source dimensions\n    if(this.image.width - sx < sWidth){\n      sWidth = this.image.width - sx;\n    }\n    if(this.image.height - sy < sHeight){\n      sHeight = this.image.height - sy;\n    }\n\n    // location on canvas to draw the croped image\n    dx = 0;\n    dy = 0;\n    // match destination with source to not scale the image\n    dWidth = sWidth;\n    dHeight = sHeight;\n\n    context.drawImage(this.image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n  };\n\n  // add \"class\" Map to our Game object\n  Game.Map = Map;\n\n})();\n\n// Game Script\n(function(){\n  // prepaire our game canvas\n  var canvas = document.getElementById(\"canvas\");\n  var context = canvas.getContext(\"2d\");\n\n  // game settings:\n  var FPS = 30;\n  var INTERVAL = 1000/FPS; // milliseconds\n  var STEP = INTERVAL/1000; // seconds\n\n  Game.GRAVITY = 10;\n  Game.FRICTION = 0.8;\n\n  // setup an object that represents the room\n  var room = {\n    width: 5000,\n    height: 3000,\n    map: new Game.Map(5000, 3000)\n  };\n\n  // generate a large image texture for the room\n  room.map.generate();\n\n  // setup player\n  var player = new Game.Player(50, 50);\n\n  // setup the magic camera !!!\n  var camera = new Game.Camera(0, 0, canvas.width, canvas.height, room.width, room.height);\n  camera.follow(player, canvas.width/2, canvas.height/2);\n\n  // Game update function\n  var update = function(){\n    player.update(STEP, room.width, room.height);\n    camera.update();\n  }\n\n  // Game draw function\n  var draw = function(){\n    // clear the entire canvas\n    context.clearRect(0, 0, canvas.width, canvas.height);\n\n    // redraw all objects\n    room.map.draw(context, camera.xView, camera.yView);\n    player.draw(context, camera.xView, camera.yView);\n  }\n\n  // Game Loop\n  var gameLoop = function(){\n    update();\n    draw();\n  }\n\n  // <-- configure play/pause capabilities:\n\n  // I'll use setInterval instead of requestAnimationFrame for compatibility reason,\n  // but it's easy to change that.\n\n  var runningId = -1;\n\n  Game.play = function(){\n    if(runningId == -1){\n      runningId = setInterval(function(){\n        gameLoop();\n      }, INTERVAL);\n      console.log(\"play\");\n    }\n  }\n\n  Game.togglePause = function(){\n    if(runningId == -1){\n      Game.play();\n    }\n    else\n    {\n      clearInterval(runningId);\n      runningId = -1;\n      console.log(\"paused\");\n    }\n  }\n\n  // -->\n\n})();\n\n// <-- configure Game controls:\n\nGame.controls = {\n  left: false,\n  up: false,\n  right: false,\n  down: false\n};\n\nwindow.addEventListener(\"keydown\", function(e){\n  switch(e.keyCode)\n  {\n    case 37: // left arrow\n      Game.controls.left = true;\n      break;\n    case 38: // up arrow\n      Game.controls.up = true;\n\n      break;\n    case 39: // right arrow\n      Game.controls.right = true;\n      break;\n    case 40: // down arrow\n      Game.controls.down = true;\n      break;\n  }\n}, false);\n\nwindow.addEventListener(\"keyup\", function(e){\n  switch(e.keyCode)\n  {\n    case 37: // left arrow\n      Game.controls.left = false;\n      break;\n    case 38: // up arrow\n      Game.controls.up = false;\n      break;\n    case 39: // right arrow\n      Game.controls.right = false;\n      break;\n    case 40: // down arrow\n      Game.controls.down = false;\n      break;\n    case 80: // key P pauses the game\n      Game.togglePause();\n      break;\n  }\n}, false);\n\n// -->\n\n// start the game when page is loaded\nwindow.onload = function(){\n  Game.play();\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/game.js\n ** module id = 0\n ** module chunks = 0\n **/"],"sourceRoot":""}